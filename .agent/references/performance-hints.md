# Performance Hints

> **來源**: [abseil.io/fast/hints.html](https://abseil.io/fast/hints.html)
> **作者**: Jeff Dean & Sanjay Ghemawat (Google)
> **最後更新**: 2025/12/16
> **保存日期**: 2024/12/24

---

## 📋 目錄

1. [效能思維的重要性](#效能思維的重要性)
2. [估算 (Estimation)](#估算-estimation)
3. [測量 (Measurement)](#測量-measurement)
4. [API 設計考量](#api-設計考量)
5. [演算法改進](#演算法改進)
6. [更好的記憶體表示](#更好的記憶體表示)
7. [減少記憶體分配](#減少記憶體分配)
8. [避免不必要的工作](#避免不必要的工作)
9. [程式碼大小考量](#程式碼大小考量)
10. [平行化與同步](#平行化與同步)

---

## 效能思維的重要性

Knuth 的名言常被斷章取義：「過早優化是萬惡之源」。但完整引述是：

> "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%."

這份文件就是關於那關鍵的 3%。

### 為何不該完全忽視效能

1. **扁平化 profile 問題**：如果開發大型系統時完全不考慮效能，最終會得到沒有明顯熱點的 profile，效能損失分散各處，難以找到改進切入點。

2. **函式庫的責任**：開發供他人使用的函式庫時，遇到效能問題的人往往無法輕易修改（需要理解他人程式碼並協商）。

3. **重構困難**：系統大量使用後，要做重大改動會變得困難。

4. **過度補償**：效能問題可能導致過度複製或過度配置服務資源。

### 建議原則

> **在不顯著影響可讀性/複雜度的前提下，選擇較快的實作方式。**

---

## 估算 (Estimation)

### 代碼類型判斷

| 代碼類型     | 效能考量程度                 |
| ------------ | ---------------------------- |
| 測試代碼     | 主要關注演算法的漸近複雜度   |
| 應用特定代碼 | 區分初始化代碼 vs 熱路徑代碼 |
| 函式庫代碼   | 最需謹慎，難以預測敏感程度   |

### 常見操作延遲參考表

```
L1 快取參考                    0.5 ns
L2 快取參考                    3 ns
分支預測失敗                   5 ns
Mutex 鎖定/解鎖 (無競爭)       15 ns
主記憶體參考                   50 ns
用 Snappy 壓縮 1KB             1,000 ns (1 μs)
從 SSD 讀取 4KB                20,000 ns (20 μs)
同一資料中心內往返             50,000 ns (50 μs)
從記憶體循序讀取 1MB           64,000 ns (64 μs)
透過 100 Gbps 網路讀取 1MB     100,000 ns (0.1 ms)
從 SSD 讀取 1MB                1,000,000 ns (1 ms)
磁碟尋道                       5,000,000 ns (5 ms)
從磁碟循序讀取 1MB             10,000,000 ns (10 ms)
加州→荷蘭→加州封包往返         150,000,000 ns (150 ms)
```

---

## 測量 (Measurement)

在開始改進之前，或遇到效能、簡潔性等權衡時，都需要測量或估算潛在的效能收益。

### 額外好處

分析不熟悉的程式碼也是了解程式碼結構和運作方式的好方法。檢查動態呼叫圖中重度使用的函式，可以讓你高層次理解「執行程式碼時發生什麼事」。

---

## API 設計考量

### 核心原則

- 將效能改進限制在封裝邊界內，避免影響公開介面
- 模組應該「深」：透過窄介面存取大量功能
- 謹慎添加新功能，避免限制未來實作

### 具體技術

| 技術                                 | 說明                             |
| ------------------------------------ | -------------------------------- |
| **Bulk APIs**                        | 批量處理而非單筆處理             |
| **View types**                       | 避免不必要的複製                 |
| **預分配/預計算參數**                | 讓呼叫者重用資源                 |
| **Thread-compatible vs Thread-safe** | 根據需求選擇適當的執行緒安全等級 |

---

## 演算法改進

最關鍵的效能改進機會來自演算法改進：

- O(N²) → O(N log N) 或 O(N)
- 避免潛在的指數行為
- 在穩定代碼中較罕見，但撰寫新代碼時值得注意

### 範例

以逆後序 (reverse post-order) 將節點加入循環檢測結構，使循環檢測變得簡單，而不是逐一添加節點和邊（每條邊需要昂貴操作）。

---

## 更好的記憶體表示

仔細考慮重要資料結構的記憶體佔用和快取佔用，常能帶來大幅節省。

### 常用技術

| 技術                 | 效果                   |
| -------------------- | ---------------------- |
| **緊湊資料結構**     | 減少快取未命中         |
| **記憶體布局**       | 減少記憶體匯流排流量   |
| **索引取代指標**     | 減少記憶體使用         |
| **批次儲存**         | 減少分配次數           |
| **內聯儲存**         | 避免額外的間接層       |
| **Arena 分配**       | 集中管理記憶體生命週期 |
| **陣列取代 map**     | 對於小型集合更高效     |
| **位元向量取代 set** | 對於密集整數集合更高效 |

---

## 減少記憶體分配

記憶體分配的成本：

1. **增加分配器時間**
2. **昂貴的初始化/銷毀**
3. **快取佔用增加**（每次分配通常在新的快取行）

### 改進技術

- **避免不必要的分配**
- **預先調整容器大小** (`resize` / `reserve`)
- **盡可能避免複製**
- **重用臨時物件**

---

## 避免不必要的工作

這是最有效的效能改進類別之一。

### 策略

| 策略                   | 說明                                       |
| ---------------------- | ------------------------------------------ |
| **快速路徑**           | 為常見情況建立專用路徑，避免通用的昂貴計算 |
| **預計算**             | 一次計算昂貴資訊，之後重用                 |
| **延遲計算**           | 直到真正需要時才執行                       |
| **迴圈外提**           | 將昂貴計算移到迴圈外部                     |
| **程式碼特化**         | 針對特定情況優化                           |
| **快取**               | 避免重複工作                               |
| **幫助編譯器**         | 讓編譯器更容易優化                         |
| **減少統計收集成本**   | 熱路徑上避免昂貴的統計                     |
| **避免熱路徑上的日誌** | 日誌可能很昂貴                             |

---

## 程式碼大小考量

效能不只是執行時間速度。大型程式碼意味著：

- 更長的編譯和連結時間
- 膨脹的二進位檔
- 更多記憶體使用
- 更多指令快取壓力
- 對分支預測器等微架構結構的負面影響

### C++ 技術

- **精簡常用內聯程式碼**
- **謹慎使用 inline**
- **減少模板實例化**
- **減少容器操作**

---

## 平行化與同步

### 利用平行性

現代機器有多核心，通常未被充分利用。常見方法：

1. 平行處理不同項目
2. 完成後合併結果
3. 先將項目分成批次，避免每個項目都付出平行化成本

> **注意**：如果沒有空閒 CPU 或記憶體頻寬飽和，平行化可能沒有幫助甚至有害。

### 攤銷鎖獲取

- 避免細粒度鎖定以減少熱路徑上的 Mutex 操作成本
- 一次獲取鎖處理整批操作，而非每個操作都重新獲取

### 其他技術

| 技術                 | 說明                         |
| -------------------- | ---------------------------- |
| **保持臨界區短**     | 減少鎖持有時間               |
| **分片減少競爭**     | 不同執行緒操作不同分片       |
| **SIMD 指令**        | 單指令多資料處理             |
| **減少虛假共享**     | 避免不同執行緒訪問同一快取行 |
| **減少上下文切換**   | 避免頻繁切換執行緒           |
| **緩衝通道用於管線** | 批量傳遞資料                 |
| **考慮無鎖方法**     | 在適當情況下使用             |

---

## 通用原則摘要

1. ✅ 在不影響可讀性的前提下，選擇較快的實作
2. ✅ 先測量再優化
3. ✅ 了解各種操作的成本
4. ✅ 批量處理優於單筆處理
5. ✅ 減少記憶體分配
6. ✅ 避免不必要的工作
7. ✅ 利用平行性但謹慎評估
8. ✅ 考慮程式碼大小影響

---

## 延伸閱讀

- [原文連結](https://abseil.io/fast/hints.html)
- [Jeff Dean 2011 Stanford Talk](https://www.youtube.com/watch?v=modXC5IWTJI)
- [A Philosophy of Software Design](https://web.stanford.edu/~ouster/cgi-bin/book.php) - by John Ousterhout
